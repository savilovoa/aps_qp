from ortools.sat.python import cp_model
import logging

# Предполагается, что logger уже настроен
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# logger.addHandler(logging.StreamHandler()) # Раскомментируйте для вывода в консоль

def create_model(products_data: list, machines_data: list, cleans: list, max_daily_prod_zero: int, count_days: int):
    """
    Создает и настраивает модель CP-SAT для задачи планирования с учетом партийности и свободного старта.
    """
    
    # --- Преобразование входных данных для совместимости со старым кодом ---
    products = [
        (p['idx'], p['qty'], p['id'], p['machine_type'], p.get('qty_minus', 0), p.get('lday', 1), p.get('qty_week', []))
        for p in products_data
    ]
    machines = [
        (m['idx'], m['name'], m['product_idx'], m['id'], m['type'], m['remain_day'])
        for m in machines_data
    ]
    
    num_days = count_days
    num_machines = len(machines)
    num_products = len(products)

    all_machines = range(num_machines)
    all_days = range(num_days)
    all_products = range(num_products)

    initial_products = [m['product_idx'] for m in machines_data]
    days_to_constrain = [m['remain_day'] for m in machines_data]

    model = cp_model.CpModel()

    jobs = {}
    work_days = []
    for m in all_machines:
        for d in all_days:
            if (m, d) not in cleans:
                work_days.append((m, d))
                jobs[(m, d)] = model.new_int_var(0, num_products - 1, f"job_{m}_{d}")

    PRODUCT_ZERO = 0

    # --- Подсчет общего количества каждого продукта ---
    product_produced_bools = {}
    for p in all_products:
        for m, d in work_days:
            product_produced_bools[p, m, d] = model.NewBoolVar(f"product_produced_{p}_{m}_{d}")
            model.Add(jobs[m, d] == p).OnlyEnforceIf(product_produced_bools[p, m, d])
            model.Add(jobs[m, d] != p).OnlyEnforceIf(product_produced_bools[p, m, d].Not())

    product_counts = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in all_products]
    for p in all_products:
        model.Add(product_counts[p] == sum(
            product_produced_bools[p, m, d] for m, d in work_days))
        if products[p][4] == 0 and products[p][1] > 0:
            model.Add(product_counts[p] >= products[p][1])

    # --- Общие ограничения (на кол-во переходов в день, типы машин) ---
    for d in all_days:
        daily_prod_zero_on_machines = [
            product_produced_bools[PRODUCT_ZERO, m, d]
            for m in all_machines if (m, d) in work_days
        ]
        if daily_prod_zero_on_machines:
            model.Add(sum(daily_prod_zero_on_machines) <= max_daily_prod_zero)
        
    for p in all_products:
        product_machine_type_req = products[p][3]
        if product_machine_type_req > 0:
            for m in all_machines:
                machine_type = machines_data[m]['type']
                if machine_type != product_machine_type_req:
                    for d in all_days:
                        if (m, d) in work_days:
                            model.Add(jobs[m, d] != p)

    # --- Логика переходов, доработок и начального состояния ---
    # ... [ВАШ СУЩЕСТВУЮЩИЙ КОД ЛОГИКИ ПЕРЕХОДОВ ДОЛЖЕН БЫТЬ ЗДЕСЬ] ...
    # Этот блок должен определять правила смены продукта, включая двухдневный переход
    # Для примера я оставлю его пустым, так как основная логика lday и старта будет ниже

    # ===============================================================================
    # НОВЫЙ БЛОК 1: Ограничение минимальной длины партии (lday) - УТОЧНЕННАЯ ВЕРСИЯ
    # ===============================================================================
    lday_list = [p[5] for p in products]
    lday_list[PRODUCT_ZERO] = 1 

    days_in_current_batch = {}
    for m, d in work_days:
        days_in_current_batch[m, d] = model.NewIntVar(0, num_days, f"days_in_batch_{m}_{d}")

    for m in all_machines:
        # Условие для первого рабочего дня машины
        first_work_day = -1
        for d in all_days:
            if (m, d) in work_days:
                first_work_day = d
                break
        if first_work_day != -1:
             model.Add(days_in_current_batch[m, first_work_day] == 1)

        # Условия для остальных дней
        for d in range(first_work_day + 1, num_days):
            if (m, d) in work_days:
                prev_d = d - 1
                while (m, prev_d) not in work_days and prev_d > 0:
                    prev_d -= 1
                
                if (m, prev_d) in work_days:
                    same_as_prev_prod = model.NewBoolVar(f"same_prod_{m}_{d}")
                    model.Add(jobs[m, d] == jobs[m, prev_d]).OnlyEnforceIf(same_as_prev_prod)
                    model.Add(jobs[m, d] != jobs[m, prev_d]).OnlyEnforceIf(same_as_prev_prod.Not())
                    
                    model.Add(days_in_current_batch[m, d] == days_in_current_batch[m, prev_d] + 1).OnlyEnforceIf(same_as_prev_prod)
                    model.Add(days_in_current_batch[m, d] == 1).OnlyEnforceIf(same_as_prev_prod.Not())

    # Основное ограничение: переход (PRODUCT_ZERO) возможен, только если
    # предыдущая партия отработала количество дней, КРАТНОЕ ее lday.
    for m in all_machines:
        for d in range(1, num_days):
            if (m, d) in work_days:
                prev_d = d - 1
                while (m, prev_d) not in work_days and prev_d > 0:
                    prev_d -= 1
                
                if (m, prev_d) in work_days:
                    is_starting_transition = model.NewBoolVar(f"start_trans_{m}_{d}")
                    model.AddConjunction([
                        jobs[m, d] == PRODUCT_ZERO,
                        jobs[m, prev_d] != PRODUCT_ZERO
                    ], is_starting_transition)
                    
                    prev_prod = jobs[m, prev_d]
                    lday_for_prev_prod = model.NewIntVar(1, num_days, f"lday_prev_{m}_{d}")
                    model.AddElement(prev_prod, lday_list, lday_for_prev_prod)
                    
                    # days_in_batch % lday == 0  <==> days_in_batch = k * lday
                    multiplier = model.NewIntVar(1, num_days, f"multiplier_{m}_{d}")
                    model.AddMultiplicationEquality(
                        days_in_current_batch[m, prev_d],
                        [multiplier, lday_for_prev_prod]
                    ).OnlyEnforceIf(is_starting_transition)


    # ===============================================================================
    # НОВЫЙ БЛОК 2: Логика начального состояния с учетом product_idx = 0
    # ===============================================================================
    for m in all_machines:
        initial_product = initial_products[m]
        remain = days_to_constrain[m]

        if initial_product == 0:
            # Если начальный продукт 0, машина может начать с любого продукта, кроме простоя.
            # Ограничение не задается, решатель выберет сам.
             if (m, 0) in work_days:
                model.Add(jobs[m, 0] != PRODUCT_ZERO)
        else:
            # Стандартная логика доработки остатка
            for d in all_days:
                if d < remain:
                    if (m, d) in work_days:
                        model.Add(jobs[m, d] == initial_product)
                else:
                    break

    # --- Ограничение на количество переходов в 21 день ---
    num_periods_21_days = num_days // 21
    for m in all_machines:
        for period in range(num_periods_21_days):
            start_day = period * 21
            end_day = start_day + 21
            prod_zero_in_period = [
                product_produced_bools[PRODUCT_ZERO, m, d]
                for d in range(start_day, end_day) if (m, d) in work_days
            ]
            if prod_zero_in_period:
                model.Add(sum(prod_zero_in_period) <= 2)

    # ===============================================================================
    # ИЗМЕНЕННЫЙ БЛОК 3: Мягкое ограничение по пропорциям (без изменений с прошлой версии)
    # ===============================================================================
    proportion_objective_terms = []

    for period in range(num_periods_21_days):
        start_day = period * 21
        end_day = start_day + 21
        
        product_counts_period = []
        for p in all_products:
            count_var = model.NewIntVar(0, num_machines * 21, f"count_prod_{p}_period_{period}")
            work_days_in_period = [
                product_produced_bools[p, m, d] 
                for m, d in work_days if start_day <= d < end_day
            ]
            model.Add(count_var == sum(work_days_in_period))
            product_counts_period.append(count_var)

        total_products_count_period = model.NewIntVar(0, num_machines * 21, f"total_prod_count_period_{period}")
        model.Add(total_products_count_period == sum(product_counts_period[p] for p in range(1, num_products)))

        proportions_input_period = [p[6][period] if len(p[6]) > period else 0 for p in products]
        total_input_quantity_period = sum(proportions_input_period)
        
        if total_input_quantity_period == 0:
            continue

        for p in range(1, num_products):
            target_qty = proportions_input_period[p]
            if target_qty == 0: continue
            
            term1 = model.NewIntVar(0, cp_model.INT64_MAX, f"p{period}_term1_{p}")
            model.AddMultiplicationEquality(term1, [product_counts_period[p], total_input_quantity_period])
            term2 = model.NewIntVar(0, cp_model.INT64_MAX, f"p{period}_term2_{p}")
            model.AddMultiplicationEquality(term2, [total_products_count_period, target_qty])
            diff = model.NewIntVar(-cp_model.INT64_MAX, cp_model.INT64_MAX, f"p{period}_diff_{p}")
            model.Add(diff == term1 - term2)
            abs_diff = model.NewIntVar(0, cp_model.INT64_MAX, f"p{period}_abs_diff_{p}")
            model.AddAbsEquality(abs_diff, diff)
            proportion_objective_terms.append(abs_diff)

    total_qty_all_products = sum(p[1] for p in products)
    downtime_penalty = round(0.1 * total_qty_all_products / len(work_days)) if work_days else 1
    if downtime_penalty < 1:
        downtime_penalty = 1
    
    # --- Целевая функция ---
    model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)
    
    return model, jobs, work_days