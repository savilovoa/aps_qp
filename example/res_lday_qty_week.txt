from ortools.sat.python import cp_model
import logging

# Предполагается, что logger уже настроен
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# logger.addHandler(logging.StreamHandler()) # Раскомментируйте для вывода в консоль

def create_model(products_data: list, machines_data: list, cleans: list, max_daily_prod_zero: int, count_days: int):
    """
    Создает и настраивает модель CP-SAT для задачи планирования.
    """
    
    # --- Преобразование входных данных для совместимости со старым кодом ---
    # Это позволяет использовать новые поля (lday, qty_week), минимально меняя старый код.
    products = [
        (p['idx'], p['qty'], p['id'], p['machine_type'], p.get('qty_minus', 0), p.get('lday', 1), p.get('qty_week', []))
        for p in products_data
    ]
    machines = [
        (m['idx'], m['name'], m['product_idx'], m['id'], m['type'], m['remain_day'])
        for m in machines_data
    ]
    
    num_days = count_days
    num_machines = len(machines)
    num_products = len(products)

    all_machines = range(num_machines)
    all_days = range(num_days)
    all_products = range(num_products)

    initial_products = []
    days_to_constrain = []
    for idx, name, product_idx, m_id, t, remain_day in machines:
        initial_products.append(product_idx)
        days_to_constrain.append(remain_day)

    model = cp_model.CpModel()

    jobs = {}
    work_days = []
    for m in range(num_machines):
        for d in range(num_days):
            if (m, d) not in cleans:
                work_days.append((m, d))
                jobs[(m, d)] = model.new_int_var(0, num_products - 1, f"job_{m}_{d}")

    PRODUCT_ZERO = 0

    # ------------ Подсчет общего количества каждого продукта ------------
    product_produced_bools = {}
    for p in all_products:
        for m, d in work_days:
            product_produced_bools[p, m, d] = model.NewBoolVar(f"product_produced_{p}_{m}_{d}")
            model.Add(jobs[m, d] == p).OnlyEnforceIf(product_produced_bools[p, m, d])
            model.Add(jobs[m, d] != p).OnlyEnforceIf(product_produced_bools[p, m, d].Not())

    product_counts = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in range(num_products)]
    for p in all_products:
        model.Add(product_counts[p] == sum(
            product_produced_bools[p, m, d] for m, d in work_days))
        if products[p][4] == 0 and products[p][1] > 0:
            model.Add(product_counts[p] >= products[p][1])

    # --- Сумма PRODUCT_ZERO в смену d не более max_daily_prod_zero ---
    for d in all_days:
        daily_prod_zero_on_machines = [
            product_produced_bools[PRODUCT_ZERO, m, d]
            for m in range(num_machines) if (m, d) in work_days
        ]
        model.Add(sum(daily_prod_zero_on_machines) <= max_daily_prod_zero)
        
    # --- Ограничение по типам машин ---
    for p in all_products:
        product_machine_type_req = products[p][3]
        if product_machine_type_req > 0:
            for m in all_machines:
                machine_type = machines_data[m]['type']
                if machine_type != product_machine_type_req:
                    for d in all_days:
                        if (m, d) in work_days:
                            model.Add(jobs[m, d] != p)

    # --- Ограничения ПЕРЕХОДА (без изменений) ---
    # (Блок кода для completed_transition, is_not_zero и т.д. остается прежним)
    # ... [ВАШ СУЩЕСТВУЮЩИЙ КОД ЛОГИКИ ПЕРЕХОДОВ ДОБАВЛЯЕТСЯ СЮДА] ...
    # Я добавлю сюда его сокращенную версию для полноты, но он должен быть идентичен вашему.
    # --- Начало существующего блока ---
    completed_transition = {}
    is_not_zero = {}
    same_as_prev = {}
    prev_is_not_zero = {}
    prev2_is_not_zero = {}
    two_day_zero = {}
    for m in range(num_machines):
        for d in range(num_days):
            completed_transition[m, d] = model.NewBoolVar(f"completed_transition_{m}_{d}")

    remain_day = [0 for _ in range(num_machines)]
    # Ограничение для первого дня (d=0)
    for m in range(num_machines):
        initial_product = initial_products[m]
        if days_to_constrain[m] > 0:
            remain_day[m] += 1
            model.Add(jobs[m, 0] == initial_product)
        # ... и т.д. ...
    # --- Конец существующего блока ---

    # ===============================================================================
    # НОВЫЙ БЛОК 1: Ограничение минимальной длины партии (lday)
    # ===============================================================================
    # Список значений lday для каждого продукта
    lday_list = [p[5] for p in products] # p[5] это lday
    lday_list[PRODUCT_ZERO] = 1 # Для продукта "простой" lday всегда 1

    # Переменная, отслеживающая количество дней подряд для текущей партии
    days_in_current_batch = {}
    for m in all_machines:
        for d in all_days:
            if (m,d) in work_days:
                days_in_current_batch[m, d] = model.NewIntVar(0, num_days, f"days_in_batch_{m}_{d}")

    for m in all_machines:
        # Условие для первого дня
        if (m, 0) in work_days:
            model.Add(days_in_current_batch[m, 0] == 1)

        # Условия для остальных дней
        for d in range(1, num_days):
            if (m, d) in work_days:
                # Находим предыдущий рабочий день
                prev_d = d - 1
                while (m, prev_d) not in work_days and prev_d > 0:
                    prev_d -= 1
                
                if (m, prev_d) in work_days:
                    # Если продукт тот же, увеличиваем счетчик, иначе сбрасываем на 1
                    same_as_prev_prod = model.NewBoolVar(f"same_prod_{m}_{d}")
                    model.Add(jobs[m, d] == jobs[m, prev_d]).OnlyEnforceIf(same_as_prev_prod)
                    model.Add(jobs[m, d] != jobs[m, prev_d]).OnlyEnforceIf(same_as_prev_prod.Not())
                    
                    model.Add(days_in_current_batch[m, d] == days_in_current_batch[m, prev_d] + 1).OnlyEnforceIf(same_as_prev_prod)
                    model.Add(days_in_current_batch[m, d] == 1).OnlyEnforceIf(same_as_prev_prod.Not())

    # Основное ограничение: начинать переход (ставить PRODUCT_ZERO) можно только если
    # предыдущая партия отработала положенное количество дней lday.
    for m in all_machines:
        for d in range(1, num_days):
            if (m, d) in work_days:
                 # Находим предыдущий рабочий день
                prev_d = d - 1
                while (m, prev_d) not in work_days and prev_d > 0:
                    prev_d -= 1
                
                if (m, prev_d) in work_days:
                    # Ситуация, когда начинается переход: текущий день - ноль, предыдущий - не ноль
                    is_starting_transition = model.NewBoolVar(f"start_trans_{m}_{d}")
                    model.Add(jobs[m, d] == PRODUCT_ZERO).OnlyEnforceIf(is_starting_transition)
                    model.Add(jobs[m, prev_d] != PRODUCT_ZERO).OnlyEnforceIf(is_starting_transition)
                    
                    # Получаем lday для предыдущего продукта
                    prev_prod = jobs[m, prev_d]
                    lday_for_prev_prod = model.NewIntVar(0, num_days, f"lday_prev_{m}_{d}")
                    model.AddElement(prev_prod, lday_list, lday_for_prev_prod)
                    
                    # Если начинается переход, то длина предыдущей партии должна быть не меньше ее lday
                    model.Add(days_in_current_batch[m, prev_d] >= lday_for_prev_prod).OnlyEnforceIf(is_starting_transition)


    # --- Ограничение на количество переходов в 21 день (было "не более 1-го простоя за неделю") ---
    num_periods_21_days = num_days // 21
    for m in range(num_machines):
        for period in range(num_periods_21_days):
            start_day = period * 21
            end_day = start_day + 21
            
            prod_zero_in_period = []
            for d in range(start_day, end_day):
                if (m, d) in work_days:
                    prod_zero_in_period.append(product_produced_bools[PRODUCT_ZERO, m, d])
            
            # Не более одного перехода (2 дня простоя) в 21-дневный период
            model.Add(sum(prod_zero_in_period) <= 2)


    # ===============================================================================
    # ИЗМЕНЕННЫЙ БЛОК 2: Мягкое ограничение по пропорциям для каждого 21-дневного периода
    # ===============================================================================
    proportion_objective_terms = []

    for period in range(num_periods_21_days):
        start_day = period * 21
        end_day = start_day + 21
        
        # Подсчет фактического производства каждого продукта в текущем периоде
        product_rescounts_period = []
        for p in all_products:
            count_var = model.NewIntVar(0, num_machines * 21, f"count_prod_{p}_period_{period}")
            # Суммируем булевы переменные только для дней текущего периода
            work_days_in_period = [
                product_produced_bools[p, m, d] 
                for m, d in work_days if start_day <= d < end_day
            ]
            if work_days_in_period:
                 model.Add(count_var == sum(work_days_in_period))
            else:
                 model.Add(count_var == 0)
            product_counts_period.append(count_var)

        # Общее количество произведенной продукции (кроме PRODUCT_ZERO) в периоде
        total_products_count_period = model.NewIntVar(0, num_machines * 21, f"total_prod_count_period_{period}")
        model.Add(total_products_count_period == sum(product_counts_period[p] for p in range(1, num_products)))

        # Целевые пропорции для текущего периода из qty_week
        proportions_input_period = [p[6][period] if len(p[6]) > period else 0 for p in products]
        total_input_quantity_period = sum(proportions_input_period)
        
        logger.debug(f"Period {period}: total_input_quantity={total_input_quantity_period}")

        # Если для периода не заданы цели, пропускаем его
        if total_input_quantity_period == 0:
            continue

        # Создаем выражения для минимизации отклонения от пропорций в этом периоде
        for p in range(1, num_products):
            target_qty = proportions_input_period[p]
            if target_qty == 0:
                continue
            
            logger.debug(f"Period {period}, Product {p}: target_qty={target_qty}")

            # term1 = product_counts_period[p] * total_input_quantity_period
            term1_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"p{period}_term1_{p}")
            model.AddMultiplicationEquality(term1_expr, [product_counts_period[p], total_input_quantity_period])

            # term2 = total_products_count_period * proportions_input_period[p]
            term2_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"p{period}_term2_{p}")
            model.AddMultiplicationEquality(term2_expr, [total_products_count_period, target_qty])

            # diff = abs(term1 - term2)
            diff_var = model.NewIntVar(-cp_model.INT32_MAX, cp_model.INT32_MAX, f"p{period}_diff_{p}")
            model.Add(diff_var == term1_expr - term2_expr)
            abs_diff_var = model.NewIntVar(0, cp_model.INT32_MAX, f"p{period}_abs_diff_{p}")
            model.AddAbsEquality(abs_diff_var, diff_var)
            
            proportion_objective_terms.append(abs_diff_var)

    # Штраф за простой (переход)
    total_qty_all_products = sum(p[1] for p in products)
    downtime_penalty = round(0.1 * total_qty_all_products / len(work_days))
    if downtime_penalty < 1:
        downtime_penalty = 1
    
    # --- Целевая функция: минимизация отклонений от пропорций и количества переходов ---
    model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)
    
    return model, jobs, work_days