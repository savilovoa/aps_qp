import collections
from ortools.sat.python import cp_model

def plan_production():
    """
    Создает и решает задачу планирования производства с помощью OR-Tools CP-SAT.
    """
    # 1. Начальные данные
    products = [  # (name, proportion_weight, machine_type_requirement)
        ("ZERO", 0, 0),    # Специальный продукт для переходов, тип 0 (любая машина)
        ("87416", 14, 1),  # Требует машину типа 1
        ("18305", 1, 0),   # Тип 0 (любая машина)
        ("18302", 1, 0),   # Тип 0 (любая машина)
    ]
    machines = [  # (name, product_idx (не используется в логике), type)
        ("t1", 1, 0),
        ("t2", 1, 1),
        ("t3", 1, 0),
    ]
    # Массив чисток: (machine_idx, day_idx)
    cleans = [
        (1, 2),  # Машина t2 на чистке в день 2
    ]
    
    # Пропорции для целевой функции. Индекс 0 игнорируется.
    # Для продуктов 1, 2, 3 пропорции как 14:1:1
    proportions_input = [prop for _, prop, _ in products]

    num_days = 7
    num_machines = len(machines)
    num_products = len(products)
    
    # Индекс "особенного" продукта для переходов
    PRODUCT_ZERO = 0
    # Значение для отображения чистки в итоговом расписании
    CLEANING_DISPLAY_CODE = -2

    # Создание модели
    model = cp_model.CpModel()

    # 2. Переменные модели
    
    # jobs[m, d] хранит индекс продукта, производимого на машине m в день d
    # Используем словарь для удобной работы с пропусками (из-за чисток)
    jobs = {}
    
    # Создаем множество дней чисток для быстрого доступа O(1)
    cleans_set = set(cleans)
    
    # Список всех рабочих дней (не чисток)
    work_days = []

    for m in range(num_machines):
        for d in range(num_days):
            if (m, d) not in cleans_set:
                work_days.append((m, d))
                # Домен переменной: от 0 до num_products - 1
                jobs[(m, d)] = model.new_int_var(0, num_products - 1, f"job_{m}_{d}")

    # product_produced_bools[p, m, d] = 1, если продукт p производится на машине m в день d
    # Эта переменная-индикатор связывает целочисленную переменную jobs с булевой логикой
    product_produced_bools = {}
    for p in range(num_products):
        for m, d in work_days:
            # Создаем булеву переменную
            bool_var = model.new_bool_var(f"product_produced_{p}_{m}_{d}")
            product_produced_bools[(p, m, d)] = bool_var
            # Связываем ее с переменной jobs: bool_var является истиной <=> jobs[(m,d)] == p
            model.add(jobs[(m, d)] == p).only_enforce_if(bool_var)
            model.add(jobs[(m, d)] != p).only_enforce_if(bool_var.not_())


    # 3. Добавление ограничений

    # Ограничение 1: Совместимость типов машин
    for p in range(num_products):
        # Если у продукта есть требование к типу машины (тип 1)
        if products[p][2] == 1:
            for m in range(num_machines):
                # И тип машины не соответствует (тип 0)
                if machines[m][2] == 0:
                    for d in range(num_days):
                        # Запрещаем производство этого продукта на этой машине во все дни
                        if (m, d) in work_days:
                            model.add(jobs[(m, d)] != p)
    
    # Ограничение 2: Логика переходов и запрет на длинные серии PRODUCT_ZERO
    for m in range(num_machines):
        for d in range(1, num_days):
            # Пропускаем дни, если текущий или предыдущий день - чистка
            if (m, d) not in work_days or (m, d - 1) not in work_days:
                continue

            prev_job = jobs[(m, d - 1)]
            current_job = jobs[(m, d)]
            
            # --- Правила смены продукта ---
            # Для наглядности создадим булевы переменные, отражающие состояние
            prev_is_not_zero = model.new_bool_var(f"prev_not_zero_{m}_{d}")
            model.add(prev_job != PRODUCT_ZERO).only_enforce_if(prev_is_not_zero)
            model.add(prev_job == PRODUCT_ZERO).only_enforce_if(prev_is_not_zero.not_())

            jobs_are_different = model.new_bool_var(f"jobs_diff_{m}_{d}")
            model.add(current_job != prev_job).only_enforce_if(jobs_are_different)
            model.add(current_job == prev_job).only_enforce_if(jobs_are_different.not_())
            
            # Правило 2a: Если предыдущий продукт не ZERO и мы его меняем, 
            # то текущий ОБЯЗАН быть ZERO (начало перехода).
            model.add(current_job == PRODUCT_ZERO).only_enforce_if([prev_is_not_zero, jobs_are_different])

            # Правило 2b: Чтобы сменить продукт (например, с A на B), нужна последовательность A -> 0 -> 0 -> B.
            # Это значит, что если вчера был ZERO, а сегодня - нет, то позавчера тоже должен был быть ZERO.
            current_is_not_zero = model.new_bool_var(f"current_not_zero_{m}_{d}")
            model.add(current_job != PRODUCT_ZERO).only_enforce_if(current_is_not_zero)
            model.add(current_job == PRODUCT_ZERO).only_enforce_if(current_is_not_zero.not_())

            # Если мы переключаемся с ZERO на что-то другое
            # (OnlyEnforceIf на [prev_is_zero, current_is_not_zero])
            if d > 1 and (m, d-2) in work_days:
                # То это разрешено, только если позавчера тоже был ZERO
                prev_prev_job = jobs[(m, d - 2)]
                model.add(prev_prev_job == PRODUCT_ZERO).only_enforce_if([prev_is_not_zero.not_(), current_is_not_zero])
            else:
                # Если d=1, переход с ZERO на другой продукт запрещен, т.к. не может быть двух дней ZERO перед ним
                model.add_implication(prev_is_not_zero.not_(), current_is_not_zero.not_())

    # Ограничение 3: Запрет на три и более подряд идущих PRODUCT_ZERO
    for m in range(num_machines):
        for d in range(num_days - 2):
            # Если все три дня (d, d+1, d+2) рабочие
            if (m, d) in work_days and (m, d + 1) in work_days and (m, d + 2) in work_days:
                # Нельзя, чтобы на всех трех днях был PRODUCT_ZERO
                model.add_bool_or([
                    jobs[(m, d)] != PRODUCT_ZERO,
                    jobs[(m, d + 1)] != PRODUCT_ZERO,
                    jobs[(m, d + 2)] != PRODUCT_ZERO,
                ])
    
    # Ограничение 4: Запрет перехода (установки PRODUCT_ZERO) сразу после чистки
    for m in range(num_machines):
        for d in range(1, num_days):
            # Если вчера была чистка, а сегодня рабочий день
            if (m, d - 1) in cleans_set and (m, d) in work_days:
                # Запрещаем ставить PRODUCT_ZERO (начинать переход)
                model.add(jobs[(m, d)] != PRODUCT_ZERO)


    # 4. Целевая функция (мягкое ограничение на пропорции)
    
    # Суммарное количество всех рабочих дней/слотов
    total_production_slots = len(work_days)
    # Сумма весов пропорций (для продуктов, которые нужно производить)
    total_proportions = sum(proportions_input[p] for p in range(1, num_products))

    deviations = [] # Список абсолютных отклонений от цели

    print("\nЦелевые показатели производства (дни):")
    for p in range(1, num_products): # Пропускаем PRODUCT_ZERO
        # Количество дней, произведенных для каждого продукта
        days_produced = model.new_int_var(0, total_production_slots, f"days_produced_{p}")
        
        # Суммируем булевы переменные по всем машинам и дням для продукта p
        model.add(days_produced == sum(product_produced_bools.get((p, m, d), 0) for m, d in work_days))
        
        # Целевое количество дней на основе пропорций
        if total_proportions > 0:
            target = total_production_slots * proportions_input[p] // total_proportions
        else:
            target = 0
        
        print(f'  - Продукт "{products[p][0]}": ~{target} дней')

        # Считаем отклонение от цели
        deviation = model.new_int_var(0, total_production_slots, f"deviation_{p}")
        model.add_abs_equality(deviation, days_produced - target)
        deviations.append(deviation)

    # Цель: минимизировать сумму всех отклонений
    model.minimize(sum(deviations))

    # 5. Решение задачи
    solver = cp_model.CpSolver()
    solver.parameters.max_time_in_seconds = 30.0 # Ограничение по времени
    status = solver.solve(model)
    
    # 6. Вывод результатов
    if status == cp_model.OPTIMAL or status == cp_model.FEASIBLE:
        print(f"\nРешение найдено. Статус: {solver.status_name}")
        print(f"Минимальное суммарное отклонение от пропорций: {solver.objective_value}\n")

        print("=" * 30)
        print("           План производства")
        print("=" * 30)
        header = "Машина | " + " | ".join(f"День {d+1}" for d in range(num_days))
        print(header)
        print("-" * len(header))
        
        results_grid = collections.defaultdict(dict)
        for m, d in work_days:
            results_grid[m][d] = solver.value(jobs[(m, d)])

        for m in range(num_machines):
            machine_name = machines[m][0]
            row = f"{machine_name:<6} |"
            for d in range(num_days):
                if (m, d) in cleans_set:
                    job_val = CLEANING_DISPLAY_CODE
                else:
                    job_val = results_grid[m][d]
                
                # Отображаем имя продукта или статус
                if job_val == CLEANING_DISPLAY_CODE:
                    display_str = "ЧИСТКА"
                else:
                    display_str = products[job_val][0]
                row += f" {display_str:<7} |"
            print(row)
        
        print("-" * len(header))

        # Вывод итоговой статистики
        print("\nИтоговая выработка по продуктам (в днях):")
        total_days_by_product = collections.defaultdict(int)
        for m in range(num_machines):
             for d in range(num_days):
                if (m,d) not in cleans_set:
                    prod_idx = results_grid[m][d]
                    total_days_by_product[prod_idx] += 1

        for p in range(num_products):
            product_name = products[p][0]
            count = total_days_by_product[p]
            print(f'  - Продукт "{product_name}": {count} дней')

    elif status == cp_model.INFEASIBLE:
        print("Решение не найдено: модель невыполнима. Проверьте ограничения.")
    else:
        print("Решение не найдено: возможно, требуется больше времени.")


if __name__ == "__main__":
    plan_production()