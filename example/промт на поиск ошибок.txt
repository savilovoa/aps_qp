Модель qttools для планирования расписания
Начальные данные:
{
"machines": [
{
"idx": 0,
"name": "ТС Тойота №1",
"product_idx": 1,
"id": "fbc4c3a0-8087-11ea-80cc-005056aab926",
"type": 0,
"remain_day": 18
},
{
"idx": 1,
"name": "ТС Тойота №2",
"product_idx": 2,
"id": "fbc4c3a1-8087-11ea-80cc-005056aab926",
"type": 0,
  "remain_day": 1
},
{
"idx": 2,
"name": "ТС Тойота №3",
"product_idx": 3,
"id": "fbc4c372-8087-11ea-80cc-005056aab926",
"type": 0,
  "remain_day": 6
}
,

{
"idx": 3,
"name": "ТС Тойота №104",
"product_idx": 5,
"id": "798b5811-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 1
},
{
"idx": 4,
"name": "ТС Тойота №106",
"product_idx": 5,
"id": "8282b5e9-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 9
},
{
"idx": 5,
"name": "ТС Тойота №107",
"product_idx": 5,
"id": "8282b5ec-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 4
},
{
"idx": 6,
"name": "ТС Тойота №108",
"product_idx": 5,
"id": "8a9f0ec4-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 4
},
{
"idx": 7,
"name": "ТС Тойота №109",
"product_idx": 5,
"id": "917b2e36-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 4
},
{
"idx": 8,
"name": "ТС Тойота №110",
"product_idx": 5,
"id": "917b2e38-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 5
},
{
"idx": 9,
"name": "ТС Тойота №111",
"product_idx": 5,
"id": "a3ef8268-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 6
},
{
"idx": 10,
"name": "ТС Тойота №113",
"product_idx": 5,
"id": "aa2b3543-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 7
},
{
"idx": 11,
"name": "ТС Тойота №114",
"product_idx": 5,
"id": "aa2b3544-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 7
},
{
"idx": 12,
"name": "ТС Тойота №115",
"product_idx": 5,
"id": "b283054f-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 9
},
{
"idx": 13,
"name": "ТС Тойота №116",
"product_idx": 5,
"id": "b2830550-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 9
},
{
"idx": 14,
"name": "ТС Тойота №117",
"product_idx": 5,
"id": "b998c049-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 13
},
{
"idx": 15,
"name": "ТС Тойота №118",
"product_idx": 5,
"id": "b998c04a-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 13
},
{
"idx": 16,
"name": "ТС Тойота №119",
"product_idx": 5,
"id": "c11b8cb5-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 22
}

,
{
"idx": 17,
"name": "ТС Тойота №120",
"product_idx": 6,
"id": "c11b8cbe-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 4
},
{
"idx": 18,
"name": "ТС Тойота №121",
"product_idx": 6,
"id": "c8696e59-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 4
},
{
"idx": 19,
"name": "ТС Тойота №122",
"product_idx": 6,
"id": "c8696e5a-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 9
},
{
"idx": 20,
"name": "ТС Тойота №123",
"product_idx": 6,
"id": "cf58caa2-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 10
},
{
"idx": 21,
"name": "ТС Тойота №124",
"product_idx": 6,
"id": "cf58caa4-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 13
},
{
"idx": 22,
"name": "ТС Тойота №125",
"product_idx": 6,
"id": "e05486a2-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 13
},
{
"idx": 23,
"name": "ТС Тойота №126",
"product_idx": 6,
"id": "e05486a4-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 17
},
{
"idx": 24,
"name": "ТС Тойота №127",
"product_idx": 6,
"id": "e8b7876d-abfa-11ec-80e0-005056aac628",
"type": 1,
"remain_day": 17
}



],
"products": [
{
"idx": 0,
"name": "",
"qty": 0,
"id": "",
"machine_type": 0,
  "qty_minus": 0,
"lday": 2,
"qty_week": [0, 0]
},
{
"idx": 1,
"name": "ст16612t3",
"qty": 0,
"id": "7ec17dc8-f3bd-4384-9738-7538ab3dc315",
"machine_type": 0,
  "qty_minus": 1,
"lday": 16,
"qty_week": [0, 3]
},
{
"idx": 2,
"name": "ст60405амt15",
"qty": 0,
"id": "9559e2e8-6e72-41f8-9dba-08aab5463623",
"machine_type": 0,
  "qty_minus": 1,
"lday": 15,
"qty_week": [0, 14]
},
{
"idx": 3,
"name": "ст81408амt14",
"qty": 20,
"id": "cd825c90-aa80-4b95-9f81-2486b871bf94",
"machine_type": 0,
  "qty_minus": 1,
"lday": 15,
"qty_week": [20, 42]
},
{
"idx": 4,
"name": "ст15406aмRSt2",
"qty": 16,
"id": "cd825c90-bb80-4b95-9f81-2486b871bf94",
"machine_type": 0,
  "qty_minus": 1,
"lday": 12,
"qty_week": [16, 42]
},
{
"idx": 5,
"name": "ст87416t1",
"qty": 219,
"id": "cd825c90-cc80-4b95-9f81-2486b871bf94",
"machine_type": 0,
  "qty_minus": 1,
"lday": 23,
"qty_week": [219, 42]
},
{
"idx": 6,
"name": "ст18422ахмt6",
"qty": 139,
"id": "cd825c90-ee80-4b95-9f81-2486b871bf94",
"machine_type": 0,
  "qty_minus": 1,
"lday": 16,
"qty_week": [139, 42]
}

],
"remains": [],
"cleans": [],
"max_daily_prod_zero": 3,
"count_days": 21,
  "dt_begin": "2025-07-01T00:00:00"
}
существующая модель для планирования продукта по слудующим критериям:
- вначале на машине дорабатывается тот продукт, который указан в начальном состоянии, на количество дней указанное в remain_day
- далее либо продолжается тот-же продукт, либо указывается переход на другой продукт длительностью 2 дня и далее планируется уже другой продукт
- для указания чистки существует специальный продукт с индексом 0 PRODUCT_ZERO
- есть ограничения на переходы - в один день не более 3-х переходов - max_daily_prod_zero
- ограничение на типы машин, для продукта с machine_type > 0 разрешены машины только type=machine_type, если machine_type = 0 то можно на любой машине
- не более одного перехода в 21 день
- если есть чистка в на машине в определенный день, то машина пропускает день производства
- использование длины партии lday - после перехода необходимо использовать то количество дней, которое укзано в lday, только после этого можно сделать либо переход, либо следующую партию на lday дней, причем следующий цикл также не менее lday и только затем возможен переход.
- если индекс продукта на машине product_idx=0,то на ней можно начинать любой продукт

- мягкое ограничение - минимизировать отклонение от заданных пропорций qty
функция оптимального результата - минимум отклонений от пропорций и минимум переходов: model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)

Код текущей модели:
def create_model(remains: list, products: list, machines: list, cleans: list, max_daily_prod_zero: int, count_days: int,
                 schedule_init: list = None):
    # products: [ # ("idx, "name", "qty", "id", "machine_type", "qty_minus")
    #     ("", 0, "", 0),
    #     ("ст87017t3", 42, "7ec17dc8-f3bd-4384-9738-7538ab3dc315", 0, 1),
    #     ("ст87416t1", 15, "9559e2e8-6e72-41f8-9dba-08aab5463623", 0, 1),
    #     ("ст2022УИСt4", 4, "cd825c90-aa80-4b95-9f81-2486b871bf94", 0, 0)
    # ]
    # machines = [ # (name, product_idx, id, type, remain_day)
    #   ("ТС Тойота №1", 1, "fbc4c3a0-8087-11ea-80cc-005056aab926", 0, 2),
    #   ("ТС Тойота №2", 1, "fbc4c3a1-8087-11ea-80cc-005056aab926", 0, 5),
    #   ("ТС Тойота №3", 3, "fbc4c372-8087-11ea-80cc-005056aab926", 0, 4),
    # ]
    # cleans: [ # ("machine_idx", "day_idx")
    # (3, 1)
    # max_daily_prod_zero = 3

    num_days = count_days
    num_machines = len(machines)
    num_products = len(products)

    all_machines = range(num_machines)
    all_days = range(num_days)
    all_products = range(num_products)

    proportions_input = [p[1] for p in products]
    ldays = [p[5] for p in products]
    initial_products = []
    days_to_constrain = []
    for idx, (_, product_idx, m_id, t, remain_day) in enumerate(machines):
        initial_products.append(product_idx)
        days_to_constrain.append(remain_day)

    model = cp_model.CpModel()

    jobs = {}
    work_days = []
    # Значение для отображения чистки в итоговом расписании
    for m in range(num_machines):
        for d in range(num_days):
            if (m, d) not in cleans:
                work_days.append((m, d))
                # Домен переменной: от 0 до num_products - 1
                jobs[(m, d)] = model.new_int_var(0, num_products - 1, f"job_{m}_{d}")

    PRODUCT_ZERO = 0  # Индекс "особенной" продукции

    # ------------ Подсчет общего количества каждого продукта ------------
    # Вспомогательные булевы переменные: product_produced[p, m, d] истинно, если продукт p производится на машине m в день d
    product_produced_bools = {}

    max_lday = max(ldays) if ldays else 1
    for p in all_products:
        for m, d in work_days:
            product_produced_bools[p, m, d] = model.NewBoolVar(f"product_produced_{p}_{m}_{d}")
            # Связь product_produced_bools с jobs
            model.Add(jobs[m, d] == p).OnlyEnforceIf(product_produced_bools[p, m, d])
            model.Add(jobs[m, d] != p).OnlyEnforceIf(product_produced_bools[p, m, d].Not())

    # Общее количество каждого продукта: product_counts[p]
    product_counts = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in range(num_products)]
    for p in all_products:
        model.Add(product_counts[p] == sum(
            product_produced_bools[p, m, d] for m, d in work_days))
        # Добавляем условие НЕ МЕНЬШЕ для некоторых продуктов
        # if products[p][4] == 0 and products[p][1] > 0:
        #     model.Add(product_counts[p] >= products[p][1])

    # Сумма PRODUCT_ZERO в смену d не более max_daily_prod_zero
    # Количество нулевого продукта по дням
    # И просто количество нулевого продукта
    for d in all_days:
        daily_prod_zero_on_machines = []
        for m in range(num_machines):
            if (m, d) in work_days:
                # Используем уже созданные product_produced_bools для эффективности
                # product_produced_bools[PRODUCT_ZERO, m, d] истинно, если на машине m в день d производится PRODUCT_ZERO
                daily_prod_zero_on_machines.append(product_produced_bools[PRODUCT_ZERO, m, d])

        # Сумма этих булевых переменных даст количество PRODUCT_ZERO в день d
        model.Add(sum(daily_prod_zero_on_machines) <= max_daily_prod_zero)

    # Ограничение по типам машин ###
    # Продукты с типом 1 могут производиться только на машинах с типом 1.
    # Продукты с типом 0 могут производиться на любых машинах.
    for p in all_products:
        # Индекс 3 в кортеже продукта - это 'machine_type'
        product_machine_type_req = products[p][3]
        if product_machine_type_req == 1:
            for m in all_machines:
                # Индекс 3 в кортеже машины - это 'type'
                machine_type = machines[m][3]
                if machine_type != 1:
                    # Эта машина не может производить данный продукт.
                    # Запрещаем назначение этого продукта на эту машину во все дни.
                    for d in all_days:
                        if (m, d) in work_days:
                            model.Add(jobs[m, d] != p)

    # Основная переменная состояния: отслеживает день внутри текущей партии
    days_in_batch = {}
    for m in all_machines:
        for d in all_days:
            days_in_batch[m, d] = model.NewIntVar(0, max_lday, f'days_in_batch_m{m}_d{d}')

    prev_lday = {}
    for m in all_machines:
        for d in all_days:
            prev_lday[m, d] = model.NewIntVar(0, max_lday, f'prev_lday_m{m}_d{d}')
            model.AddElement(jobs[m, d], ldays, prev_lday[m, d])

    batch_end_complite = {}

    # Ограничения ПЕРЕХОДА
    # Переменные для отслеживания завершения двухдневного перехода
    completed_transition = {}
    is_not_zero = {}
    same_as_prev = {}
    prev_is_not_zero = {}
    prev2_is_not_zero = {}
    two_day_zero = {}
    start_batch = {}

    remain_day = [0 for _ in range(num_machines)]
    # Ограничение для первого дня (d=0)
    for m in range(num_machines):
        initial_product = initial_products[m]
        is_initial_product = model.NewBoolVar(f"is_initial_product_{m}_0")
        model.Add(jobs[m, 0] == initial_product).OnlyEnforceIf(is_initial_product)
        model.Add(jobs[m, 0] != initial_product).OnlyEnforceIf(is_initial_product.Not())

        is_not_zero[m, 0] = model.NewBoolVar(f"is_not_zero_{m}_0")
        model.Add(jobs[m, 0] == PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 0].Not())
        model.Add(jobs[m, 0] != PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 0])

        product_lday = ldays[initial_product]
        batch_end_complite[m, 0] = model.NewBoolVar(f"batch_end_complite_m{m}_d0")

        if days_to_constrain[m] > 0:
            remain_day[m] += 1
            model.Add(jobs[m, 0] == initial_product)
            # выставляем начальное значение остатка партии
            start_val = product_lday - days_to_constrain[m] + 1
            model.Add(days_in_batch[m, 0] == start_val)
        elif initial_product == 0:
            model.Add(days_in_batch[m, 0] == 1).OnlyEnforceIf([is_not_zero[m, 0]])
            model.Add(jobs[m, 0] != PRODUCT_ZERO)
        else:

            # Первый день: либо начальный продукт, либо PRODUCT_ZERO
            model.AddBoolOr([is_initial_product, is_not_zero[m, 0].Not()])
            # Первый день: либо начало партии, либо 0, если переход
            model.Add(days_in_batch[m, 0] == 1).OnlyEnforceIf([is_initial_product, is_not_zero[m, 0]])
            model.Add(days_in_batch[m, 0] == 0).OnlyEnforceIf(is_not_zero[m, 0].Not())

        # Устанавливаем completed_transition для дня 0
        completed_transition[m, 0] = model.NewBoolVar(f"completed_transition_{m}_0")
        model.Add(completed_transition[m, 0] == 0)  # Нет перехода в день 0

        model.Add(days_in_batch[m, 0] == prev_lday[m, 0]).OnlyEnforceIf(batch_end_complite[m, 0])
        model.Add(days_in_batch[m, 0] != prev_lday[m, 0]).OnlyEnforceIf(batch_end_complite[m, 0].Not())

    # Логика переходов для дней d ≥ 1
    pred_start_batch = {}
    for m in range(num_machines):
        for d in range(1, num_days):
            initial_product = initial_products[m]
            if (m, d) not in cleans and (m, d - 1) not in cleans:
                pred_idx = d - 1
            elif (m, d) in cleans:
                continue
            elif (m, d - 1) in cleans:
                pred_idx = d - 2

            if days_to_constrain[m] > remain_day[m]:
                model.Add(jobs[m, d] == initial_product)
                remain_day[m] += 1

            same_as_prev[m, d] = model.NewBoolVar(f"same_as_prev_{m}_{d}")
            model.Add(jobs[m, d] == jobs[m, pred_idx]).OnlyEnforceIf(same_as_prev[m, d])
            model.Add(jobs[m, d] != jobs[m, pred_idx]).OnlyEnforceIf(same_as_prev[m, d].Not())

            is_not_zero[m, d] = model.NewBoolVar(f"is_not_zero_{m}_{d}")
            model.Add(jobs[m, d] != PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, d])
            model.Add(jobs[m, d] == PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, d].Not())

            prev_is_not_zero[m, d] = model.NewBoolVar(f"prev_is_not_zero_{m}_{d}")
            model.Add(jobs[m, pred_idx] != PRODUCT_ZERO).OnlyEnforceIf(prev_is_not_zero[m, d])
            model.Add(jobs[m, pred_idx] == PRODUCT_ZERO).OnlyEnforceIf(prev_is_not_zero[m, d].Not())

            # Проверяем, был ли завершен двухдневный переход
            completed_transition[m, d] = model.NewBoolVar(f"completed_transition_{m}_{d}")
            model.AddBoolAnd(prev_is_not_zero[m, d].Not(), is_not_zero[m, d].Not()).OnlyEnforceIf(
                completed_transition[m, d])
            model.AddBoolOr(prev_is_not_zero[m, d], is_not_zero[m, d]).OnlyEnforceIf(
                completed_transition[m, d].Not())

            # логика расчета количества партии

            model.Add(days_in_batch[m, d] == 0).OnlyEnforceIf(is_not_zero[m, d].Not())
            model.Add(days_in_batch[m, d] == 1).OnlyEnforceIf([batch_end_complite[m, pred_idx], is_not_zero[m, d]])
            model.Add(days_in_batch[m, d] == days_in_batch[m, pred_idx] + 1).OnlyEnforceIf([batch_end_complite[m, pred_idx].Not(), is_not_zero[m, d]])

            batch_end_complite[m, d] = model.NewBoolVar(f"batch_end_complite_m{m}_d{d}")
            model.Add(days_in_batch[m, d] == prev_lday[m ,d]).OnlyEnforceIf(batch_end_complite[m, d])
            model.Add(days_in_batch[m, d] != prev_lday[m, d]).OnlyEnforceIf(batch_end_complite[m, d].Not())

            pred_start_batch[m, d] = model.NewBoolVar(f"pred_start_batch_m{m}_d{d}")
            model.AddBoolAnd([same_as_prev[m, d], batch_end_complite[m, pred_idx]]).OnlyEnforceIf(
                pred_start_batch[m, d])
            model.AddBoolOr([same_as_prev[m, d].Not(), batch_end_complite[m, pred_idx].Not()]).OnlyEnforceIf(
                pred_start_batch[m, d].Not())

            start_batch[m, d] = model.NewBoolVar(f"start_batch_m{m}_d{d}")
            model.AddBoolOr([pred_start_batch[m, d], completed_transition[m, d]]).OnlyEnforceIf(
                start_batch[m, d])
            model.AddBoolAnd([pred_start_batch[m, d].Not(), completed_transition[m, d].Not()]).OnlyEnforceIf(
                start_batch[m, d].Not())

            model.Add(jobs[m, d] == jobs[m, pred_idx]).OnlyEnforceIf([batch_end_complite[m, pred_idx].Not(), prev_is_not_zero[m, d]])


            # ### НАЧАЛО НОВОГО БЛОКА: Ограничение на повышение индекса продукта ###
            # Это ограничение срабатывает только в день `d`, когда завершился двухдневный переход,
            # что определяется переменной completed_transition[m, d].

            # 1. Находим индекс рабочего дня перед началом перехода.
            #    Переход занимал дни `pred_pred_idx` и `pred_idx`. Ищем день до `pred_pred_idx`.
            day_before_transition_start = pred_idx - 2
            while day_before_transition_start >= 0 and (m, day_before_transition_start) in cleans:
                day_before_transition_start -= 1

            # 2. Применяем ограничение, только если такой день существует в расписании.
            if day_before_transition_start >= 0:
                # Переменная, указывающая на продукт до начала перехода.
                product_before = jobs[(m, day_before_transition_start)]
                product_before_is_not_zero = model.NewBoolVar(f"prod_before_not_zero_{m}_{d}")
                model.Add(product_before != PRODUCT_ZERO).OnlyEnforceIf(product_before_is_not_zero)
                model.Add(product_before == PRODUCT_ZERO).OnlyEnforceIf(product_before_is_not_zero.Not())
                model.Add(jobs[m, d] > product_before).OnlyEnforceIf(
                    [completed_transition[m, pred_idx], product_before_is_not_zero]
                )
            # ### КОНЕЦ НОВОГО БЛОКА ###

            # Ограничения:
            # Если текущий день - не ноль, то либо:
            # 1) тот же продукт, что и вчера (если вчера не ноль)
            # 2) завершен двухдневный переход

            model.AddBoolOr([
                is_not_zero[m, d].Not(),  # Текущий день - PRODUCT_ZERO
                same_as_prev[m, d],  # Тот же продукт, что вчера
                completed_transition[m, pred_idx]  # Завершен двухдневный переход
            ])
            # Запрет на 3-й ZERO
            model.add(jobs[m, d] != PRODUCT_ZERO).OnlyEnforceIf(completed_transition[m, pred_idx])
            # Запрет на переход в последние 2 дня
            # if d >= count_days - 2:
            #     model.add(jobs[m, d] != PRODUCT_ZERO)

    # не более 1-го простоя за неделю
    for m in range(num_machines):
        prod_zero_on_machine = []
        for d in all_days:
            if not (m, d) in cleans:
                prod_zero_on_machine.append(product_produced_bools[PRODUCT_ZERO, m, d])
        model.Add(sum(prod_zero_on_machine) <= 2)

    # ### НОВОЕ: Добавление начального расписания как подсказки (hint) ###
    if schedule_init:
        for m in all_machines:
            for d in all_days:
                # Подсказку можно добавить только для существующей переменной (т.е. не в день чистки)
                if (m, d) in work_days:
                    initial_product_idx = schedule_init[m][d]
                    # Игнорируем значения чистки (-2) и другие некорректные
                    if initial_product_idx and initial_product_idx >= 0:
                        model.AddHint(jobs[(m, d)], initial_product_idx)

                        # 2. Подсказки для вспомогательных переменных
                        # 'product_produced_bools'
                        for p in all_products:
                            hint_value = 1 if p == initial_product_idx else 0
                            model.AddHint(product_produced_bools[p, m, d], hint_value)

                        # 'is_not_zero'
                        is_not_zero_hint = 1 if initial_product_idx != PRODUCT_ZERO else 0
                        model.AddHint(is_not_zero[m, d], is_not_zero_hint)

                        # 'same_as_prev' and 'completed_transition'
                        if d > 0 and schedule_init[m][d-1] and schedule_init[m][d-1] > 0:
                            d_prev = d - 1
                            prev_product_id_hint = schedule_init[m][d_prev]

                            # # 'same_as_prev'
                            # same_as_prev_hint = 1 if initial_product_idx == prev_product_id_hint else 0
                            # model.AddHint(same_as_prev[m, d], same_as_prev_hint)

                            if d > 1 and schedule_init[m][d-2] and schedule_init[m][d-2] > 0:
                                d_prev = d - 1
                                d_prev2 = d - 2
                                prev_product_id_hint = schedule_init[m][d_prev]
                                prev2_product_id_hint = schedule_init[m][d_prev2]

                                # 'completed_transition'
                                completed_transition_hint = 1 if (
                                            prev_product_id_hint == PRODUCT_ZERO and prev2_product_id_hint == PRODUCT_ZERO) else 0
                                model.AddHint(completed_transition[m, d], completed_transition_hint)

        # ### END: ADDING INITIAL STATE (HINTS) ###

    # ------------ Мягкое ограничение: Пропорции продукции (для продуктов с индексом > 0) ------------
    # Цель: минимизировать отклонение от заданных пропорций
    # Пропорции касаются только продуктов p > 0.
    # Мы хотим, чтобы product_counts[p1] / product_counts[p2] было близко к proportions_input[p1] / proportions_input[p2]
    # Это эквивалентно product_counts[p1] * proportions_input[p2] ~= product_counts[p2] * proportions_input[p1]

    # Корректировка общего количества распланированного на остатки на станках, не включаемых в план
    products_init_machines = [0 for _ in range(len(products))]
    products_count_corr = [0 for _ in range(len(products))]
    for m in all_machines:
        if initial_products[m] > 0:
            products_init_machines[initial_products[m]] = products_init_machines[initial_products[m]] + days_to_constrain[m]
    for p in range(1, len(products)):
        if proportions_input[p] < products_init_machines[p]:
            products_count_corr[p] = products_init_machines[p] - proportions_input[p]

    product_counts_calc = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in range(num_products)]
    for p in all_products:
        model.Add(product_counts_calc[p] == sum(
            product_produced_bools[p, m, d] for m, d in work_days) - products_count_corr[p])

    total_products_count = model.NewIntVar(0, num_machines * num_days, "total_products_count")
    model.Add(total_products_count == sum(product_counts[p] for p in range(1, len(products))))

    total_products_count_calc = model.NewIntVar(0, num_machines * num_days, "total_products_count_calc")
    model.Add(total_products_count_calc == sum(product_counts_calc[p] for p in range(1, len(products))))

    total_input_quantity = sum(proportions_input)
    logger.debug(f"total_input_quantity={total_input_quantity}")
    proportion_objective_terms = []

    for p in range(1, len(products)):  # Skip p == 0
        logger.debug(f"proportions_input[{p}]={proportions_input[p]}")

        # product_counts[p] * total_input_quantity
        term1_expr = model.NewIntVar(0, num_machines * num_days * total_input_quantity,
                                     f"term1_{p}")
        model.AddMultiplicationEquality(term1_expr, [product_counts_calc[p], total_input_quantity])

        # total_products_count * proportions_input[p1_idx]
        term2_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"term2_{p}")
        model.AddMultiplicationEquality(term2_expr, [total_products_count_calc,
                                                     model.NewConstant(proportions_input[p])])

        # diff = term1_expr - term2_expr
        diff_var = model.NewIntVar(-cp_model.INT32_MAX, cp_model.INT32_MAX, f"diff_{p}")
        model.Add(diff_var == (term1_expr - term2_expr))
        abs_diff_var = model.NewIntVar(0, cp_model.INT32_MAX, f"abs_diff_{p}")
        model.AddAbsEquality(abs_diff_var, diff_var)
        proportion_objective_terms.append(abs_diff_var)

    downtime_penalty = total_input_quantity * 5

    model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)


    return (model, jobs, product_counts, proportion_objective_terms, total_products_count, prev_lday, start_batch,
            batch_end_complite, days_in_batch, completed_transition, pred_start_batch, same_as_prev)


Но с именно с этими начальными данными, указанными в начале, никаких решений не строится - выдается INFEASIBLE.
Причем если в первой машине поставить remain_day=17 и меньше, то решения начинают строится.
Где ошибка в модели?