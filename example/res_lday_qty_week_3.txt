from ortools.sat.python import cp_model
import logging

# Предполагается, что logger уже настроен
logger = logging.getLogger(__name__)


def create_model(remains: list, products_data: list, machines_data: list, cleans: list, max_daily_prod_zero: int, count_days: int):
    """
    Создает и настраивает модель CP-SAT для планирования расписания.
    """
    
    # Для удобства преобразуем входные списки словарей в нужные структуры
    # Это улучшает читаемость кода по сравнению с доступом по индексам
    machines = [
        {"idx": m["idx"], "name": m["name"], "product_idx": m["product_idx"], "id": m["id"], "type": m["type"], "remain_day": m["remain_day"]}
        for m in machines_data
    ]
    products = [
        {"idx": p["idx"], "name": p["name"], "qty": p["qty"], "id": p["id"], "machine_type": p["machine_type"], "qty_minus": p["qty_minus"], "lday": p["lday"], "qty_week": p["qty_week"]}
        for p in products_data
    ]

    num_days = count_days
    num_machines = len(machines)
    num_products = len(products)

    all_machines = range(num_machines)
    all_days = range(num_days)
    all_products = range(num_products)

    # Извлекаем начальные данные по машинам
    initial_products = [m['product_idx'] for m in machines]
    days_to_constrain = [m['remain_day'] for m in machines]

    model = cp_model.CpModel()

    jobs = {}
    work_days = []
    for m in all_machines:
        for d in all_days:
            # Пропускаем дни, когда машина на чистке
            if (m, d) not in cleans:
                work_days.append((m, d))
                jobs[(m, d)] = model.NewIntVar(0, num_products - 1, f"job_{m}_{d}")

    PRODUCT_ZERO = 0  # Индекс продукта-простоя/перехода

    # --- Подсчет общего количества каждого продукта (без изменений) ---
    product_produced_bools = {}
    for p in all_products:
        for m, d in work_days:
            product_produced_bools[p, m, d] = model.NewBoolVar(f"product_produced_{p}_{m}_{d}")
            model.Add(jobs[m, d] == p).OnlyEnforceIf(product_produced_bools[p, m, d])
            model.Add(jobs[m, d] != p).OnlyEnforceIf(product_produced_bools[p, m, d].Not())

    product_counts = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in all_products]
    for p in all_products:
        model.Add(product_counts[p] == sum(product_produced_bools[p, m, d] for m, d in work_days))
        if products[p]['qty_minus'] == 0 and products[p]['qty'] > 0:
            model.Add(product_counts[p] >= products[p]['qty'])

    # --- Ограничения на ежедневные переходы и типы машин (без изменений) ---
    for d in all_days:
        daily_prod_zero_on_machines = []
        for m in all_machines:
            if (m, d) in work_days:
                daily_prod_zero_on_machines.append(product_produced_bools[PRODUCT_ZERO, m, d])
        model.Add(sum(daily_prod_zero_on_machines) <= max_daily_prod_zero)

    for p in all_products:
        product_machine_type_req = products[p]['machine_type']
        if product_machine_type_req > 0: # > 0 для общности
            for m in all_machines:
                machine_type = machines[m]['type']
                if machine_type != product_machine_type_req:
                    for d in all_days:
                        if (m, d) in work_days:
                            model.Add(jobs[m, d] != p)
    
    # ### НОВЫЙ БЛОК 1: Ограничение на минимальную длину партии (lday) ###
    for m in all_machines:
        for d in all_days:
            # Пропускаем, если день нерабочий
            if (m, d) not in work_days:
                continue

            for p in all_products:
                # Нас интересуют только продукты с реальной минимальной партией > 1
                lday = products[p]['lday']
                if lday <= 1:
                    continue

                # Переменная, которая будет истинной, если на машине m в день d началось производство продукта p
                starts_new_batch = model.NewBoolVar(f'starts_batch_{m}_{d}_{p}')
                
                # Условия для начала новой партии:
                if d == 0:
                    # В первый день любая работа (кроме доработки того же продукта) считается началом новой партии
                    if initial_products[m] != p or days_to_constrain[m] == 0:
                         model.Add(jobs[m, d] == p).OnlyEnforceIf(starts_new_batch)
                         model.Add(jobs[m, d] != p).OnlyEnforceIf(starts_new_batch.Not())
                    else: # Если это доработка, то это не старт новой партии
                         model.Add(starts_new_batch == False)
                else:
                    # В последующие дни - это смена продукта
                    prev_d = d - 1
                    while (m, prev_d) in cleans and prev_d > 0:
                        prev_d -= 1
                    
                    if (m, prev_d) not in work_days: # если предыдущего рабочего дня не было
                        model.Add(jobs[m, d] == p).OnlyEnforceIf(starts_new_batch)
                        model.Add(jobs[m, d] != p).OnlyEnforceIf(starts_new_batch.Not())
                    else:
                        is_change = model.NewBoolVar(f'is_change_{m}_{d}_{p}')
                        model.Add(jobs[m, prev_d] != p).OnlyEnforceIf(is_change)
                        model.Add(jobs[m, prev_d] == p).OnlyEnforceIf(is_change.Not())
                        
                        # Новая партия p начинается, если сегодня p, а вчера был не p
                        model.AddBoolAnd([is_change, jobs[m, d] == p]).OnlyEnforceIf(starts_new_batch)
                        model.AddBoolOr([is_change.Not(), jobs[m, d] != p]).OnlyEnforceIf(starts_new_batch.Not())

                # Если партия продукта p началась в день d, то она должна продолжаться lday дней
                for k in range(1, lday):
                    next_d = d + k
                    if next_d < num_days and (m, next_d) in work_days:
                        # Принудительно устанавливаем тот же продукт на следующие дни
                        model.Add(jobs[m, next_d] == p).OnlyEnforceIf(starts_new_batch)

    # --- Логика переходов ---
    # Переменные для отслеживания завершения двухдневного перехода
    completed_transition = {}
    is_not_zero = {}
    same_as_prev = {}
    
    remain_day_counters = [0] * num_machines

    # Ограничение для первого дня (d=0)
    for m in all_machines:
        initial_product = initial_products[m]
        model.Add(completed_transition[m, 0] == 0) # Нет перехода в день 0

        if (m, 0) not in work_days: continue

        if days_to_constrain[m] > 0:
            remain_day_counters[m] += 1
            model.Add(jobs[m, 0] == initial_product)
        else:
            # ### ИЗМЕНЕНИЕ 3: Логика свободного старта ###
            # Если начальный продукт - 0, то можно начинать любой продукт
            if initial_product == PRODUCT_ZERO:
                # Никаких ограничений на jobs[m, 0], решатель выберет сам
                pass
            else:
                # Старая логика: либо тот же продукт, либо переход (PRODUCT_ZERO)
                is_initial_product = model.NewBoolVar(f"is_initial_product_{m}_0")
                is_not_zero[m, 0] = model.NewBoolVar(f"is_not_zero_{m}_0")
                model.Add(jobs[m, 0] == initial_product).OnlyEnforceIf(is_initial_product)
                model.Add(jobs[m, 0] != initial_product).OnlyEnforceIf(is_initial_product.Not())
                model.Add(jobs[m, 0] == PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 0].Not())
                model.Add(jobs[m, 0] != PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 0])
                model.AddBoolOr([is_initial_product, is_not_zero[m, 0].Not()])

    # Остальная логика переходов остается почти без изменений
    # ... (код для d=1 и d>=2 остается таким же, как в оригинале) ...
    # Я скопирую вашу логику переходов для полноты, предполагая, что она верна
    
    # Ограничение для второго дня (d=1)
    for m in range(num_machines):
        if (m, 1) not in work_days: 
            model.Add(completed_transition[m, 1] == 0)
            continue
        
        initial_product = initial_products[m]
        is_not_zero[m, 1] = model.NewBoolVar(f"is_not_zero_{m}_1")
        model.Add(jobs[m, 1] != PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 1])
        model.Add(jobs[m, 1] == PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, 1].Not())
        
        if days_to_constrain[m] > remain_day_counters[m]:
            model.Add(jobs[m, 1] == initial_product)
            remain_day_counters[m] += 1
            model.Add(completed_transition[m, 1] == 0)
        else:
            if (m, 0) in work_days:
                same_as_prev[m, 1] = model.NewBoolVar(f"same_as_prev_{m}_1")
                model.Add(jobs[m, 1] == jobs[m, 0]).OnlyEnforceIf(same_as_prev[m, 1])
                model.Add(jobs[m, 1] != jobs[m, 0]).OnlyEnforceIf(same_as_prev[m, 1].Not())

                prev_is_zero = model.NewBoolVar(f"prev_is_zero_{m}_1")
                model.Add(jobs[m, 0] == PRODUCT_ZERO).OnlyEnforceIf(prev_is_zero)
                model.Add(jobs[m, 0] != PRODUCT_ZERO).OnlyEnforceIf(prev_is_zero.Not())

                model.Add(jobs[m, 1] == PRODUCT_ZERO).OnlyEnforceIf(prev_is_zero)
                model.AddBoolOr([is_not_zero[m, 1].Not(), same_as_prev[m, 1]]).OnlyEnforceIf(prev_is_zero.Not())
                model.Add(completed_transition[m, 1] == prev_is_zero)
            else: # если день 0 был чисткой
                model.Add(completed_transition[m, 1] == 0)


    # Логика переходов для дней d >= 2 (Ваш код)
    # ... (здесь должен быть ваш код для переходов)
    # Важно, чтобы эта логика корректно работала с новой логикой lday
    # Код ниже - это ваша логика, возможно, требующая адаптации к пропускам дней 'cleans'
    for m in range(num_machines):
        for d in range(2, num_days):
            if (m, d) not in work_days: continue

            # Логика определения предыдущих рабочих дней
            pred_idx = d - 1
            while (m, pred_idx) in cleans and pred_idx > 0: pred_idx -= 1
            
            pred_pred_idx = pred_idx - 1
            while (m, pred_pred_idx) in cleans and pred_pred_idx > 0: pred_pred_idx -= 1

            # Если предыдущих дней нет, то нет и перехода
            if (m, pred_idx) not in work_days or (m, pred_pred_idx) not in work_days:
                model.Add(completed_transition[m, d] == 0)
                continue

            # Доработка
            if days_to_constrain[m] > remain_day_counters[m]:
                model.Add(jobs[m, d] == initial_products[m])
                remain_day_counters[m] += 1
                model.Add(completed_transition[m, d] == 0)
                continue
            
            # Стандартная логика перехода
            is_not_zero[m, d] = model.NewBoolVar(f"is_not_zero_{m}_{d}")
            model.Add(jobs[m, d] != PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, d])
            model.Add(jobs[m, d] == PRODUCT_ZERO).OnlyEnforceIf(is_not_zero[m, d].Not())

            prev_is_not_zero = model.NewBoolVar(f"prev_is_not_zero_{m}_{d}")
            model.Add(jobs[m, pred_idx] != PRODUCT_ZERO).OnlyEnforceIf(prev_is_not_zero)
            model.Add(jobs[m, pred_idx] == PRODUCT_ZERO).OnlyEnforceIf(prev_is_not_zero.Not())
            
            prev2_is_not_zero = model.NewBoolVar(f"prev2_is_not_zero_{m}_{d}")
            model.Add(jobs[m, pred_pred_idx] != PRODUCT_ZERO).OnlyEnforceIf(prev2_is_not_zero)
            model.Add(jobs[m, pred_pred_idx] == PRODUCT_ZERO).OnlyEnforceIf(prev2_is_not_zero.Not())

            two_day_zero = model.NewBoolVar(f"two_day_zero_{m}_{d}")
            model.AddBoolAnd([prev_is_not_zero.Not(), prev2_is_not_zero.Not()]).OnlyEnforceIf(two_day_zero)
            model.AddBoolOr([prev_is_not_zero, prev2_is_not_zero]).OnlyEnforceIf(two_day_zero.Not())
            
            model.Add(completed_transition[m, d] == two_day_zero)
            
            same_as_prev[m, d] = model.NewBoolVar(f"same_as_prev_{m}_{d}")
            model.Add(jobs[m, d] == jobs[m, pred_idx]).OnlyEnforceIf(same_as_prev[m, d])
            model.Add(jobs[m, d] != jobs[m, pred_idx]).OnlyEnforceIf(same_as_prev[m, d].Not())

            model.AddBoolOr([
                is_not_zero[m, d].Not(),
                same_as_prev[m, d],
                completed_transition[m, d]
            ])
            model.Add(jobs[m, d] != PRODUCT_ZERO).OnlyEnforceIf(completed_transition[m, d])
            
            if d >= count_days - 2:
                model.Add(jobs[m, d] != PRODUCT_ZERO)

    # не более одного перехода в 21 день
    num_weeks_lim = num_days // 21
    for m in range(num_machines):
        for w in range(num_weeks_lim):
            start_day = w * 21
            end_day = (w + 1) * 21
            transitions_in_week = []
            for d in range(start_day + 1, end_day): # переход не может быть в первый день периода
                if (m,d) in completed_transition:
                     transitions_in_week.append(completed_transition[m,d])
            if transitions_in_week:
                model.Add(sum(transitions_in_week) <= 1)


    # ### ИЗМЕНЕННЫЙ БЛОК 2: Мягкое ограничение пропорций по 21-дневным периодам ###
    proportion_objective_terms = []
    num_weeks = num_days // 21
    
    # Проходим по каждому 21-дневному периоду
    for w in range(num_weeks):
        start_day = w * 21
        end_day = (w + 1) * 21
        
        days_in_week = [d for d in range(start_day, end_day)]
        work_days_in_week = [(m, d) for m, d in work_days if start_day <= d < end_day]
        
        # Подсчет количества каждого продукта за этот период
        product_counts_weekly = {}
        for p in all_products:
            product_counts_weekly[p] = model.NewIntVar(0, num_machines * 21, f"count_prod_{p}_week_{w}")
            model.Add(product_counts_weekly[p] == sum(product_produced_bools[p, m, d] 
                                                    for m, d in work_days_in_week))

        # Общее количество всех продуктов (кроме ZERO) за период
        total_products_count_weekly = model.NewIntVar(0, num_machines * 21, f"total_products_week_{w}")
        model.Add(total_products_count_weekly == sum(product_counts_weekly[p] for p in range(1, num_products)))
        
        # Целевые пропорции для текущего периода из `qty_week`
        proportions_input_weekly = [products[p]['qty_week'][w] for p in all_products]
        total_input_quantity_weekly = sum(proportions_input_weekly)
        
        # Если для периода нет целевых значений, пропускаем его
        if total_input_quantity_weekly == 0:
            continue
            
        # Применяем ту же логику пропорций, но для данных текущего периода
        for p in range(1, num_products):
            if proportions_input_weekly[p] == 0:
                continue

            # term1 = фактическое_кол-во[p] * сумма_целевых_кол-в
            term1_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"term1_{p}_week_{w}")
            model.AddMultiplicationEquality(term1_expr, [product_counts_weekly[p], total_input_quantity_weekly])

            # term2 = общее_факт_кол-во * целевое_кол-во[p]
            term2_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"term2_{p}_week_{w}")
            model.AddMultiplicationEquality(term2_expr, [total_products_count_weekly, model.NewConstant(proportions_input_weekly[p])])

            # diff = |term1 - term2|
            diff_var = model.NewIntVar(-cp_model.INT32_MAX, cp_model.INT32_MAX, f"diff_{p}_week_{w}")
            model.Add(diff_var == term1_expr - term2_expr)
            abs_diff_var = model.NewIntVar(0, cp_model.INT32_MAX, f"abs_diff_{p}_week_{w}")
            model.AddAbsEquality(abs_diff_var, diff_var)
            
            proportion_objective_terms.append(abs_diff_var)

    # Штраф за простои/переходы
    total_qty_sum = sum(p['qty'] for p in products)
    downtime_penalty = round(0.1 * total_qty_sum / len(work_days)) if work_days else 1
    if downtime_penalty < 1:
        downtime_penalty = 1
    
    # Целевая функция: минимизировать отклонения от пропорций (по всем периодам) и количество переходов
    model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)

    return model, jobs, product_counts