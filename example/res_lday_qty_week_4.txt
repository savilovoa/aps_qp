from ortools.sat.python import cp_model
import logging

# Предполагается, что logger уже настроен
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
# handler = logging.StreamHandler()
# logger.addHandler(handler)

def create_model(remains: list, products: list, machines: list, cleans: list, max_daily_prod_zero: int, count_days: int):

    num_days = count_days
    num_machines = len(machines)
    num_products = len(products)

    all_machines = range(num_machines)
    all_days = range(num_days)
    all_products = range(num_products)

    # Извлекаем данные из входных структур
    proportions_input = [p['qty'] for p in products]
    ldays = [p.get('lday', 1) for p in products] # Извлекаем lday, по умолчанию 1
    # Для продукта 0 (простой) lday не имеет значения, но для индексации установим 1
    if len(ldays) > 0:
        ldays[0] = 1

    initial_products = [m['product_idx'] for m in machines]
    days_to_constrain = [m['remain_day'] for m in machines]

    model = cp_model.CpModel()

    jobs = {}
    work_days = []
    for m in all_machines:
        for d in all_days:
            if (m, d) not in cleans:
                work_days.append((m, d))
                jobs[(m, d)] = model.NewIntVar(0, num_products - 1, f"job_{m}_{d}")

    PRODUCT_ZERO = 0

    # ------------ НОВОЕ: Переменные для отслеживания партий ------------
    # batch_day[m, d] - номер дня в текущей партии для машины m в день d
    # 0 - если простой, 1 - начало новой партии, >1 - продолжение партии
    max_lday = max(ldays) if ldays else 1
    batch_day = {}
    for m in all_machines:
        for d in all_days:
            if (m, d) in work_days:
                batch_day[m, d] = model.NewIntVar(0, max_lday, f"batch_day_{m}_{d}")
            else:
                # Для дней чистки переменная не нужна, но для логики может понадобиться фиктивное значение
                pass

    # НОВОЕ: Переменная для хранения остатка дней в партии на конец периода
    final_remain_day = [model.NewIntVar(0, max_lday, f"final_remain_day_{m}") for m in all_machines]


    # ------------ Подсчет общего количества каждого продукта ------------
    product_produced_bools = {}
    for p in all_products:
        for m, d in work_days:
            product_produced_bools[p, m, d] = model.NewBoolVar(f"product_produced_{p}_{m}_{d}")
            model.Add(jobs[m, d] == p).OnlyEnforceIf(product_produced_bools[p, m, d])
            model.Add(jobs[m, d] != p).OnlyEnforceIf(product_produced_bools[p, m, d].Not())

    product_counts = [model.NewIntVar(0, num_machines * num_days, f"count_prod_{p}") for p in all_products]
    for p in all_products:
        model.Add(product_counts[p] == sum(
            product_produced_bools[p, m, d] for m, d in work_days if (p,m,d) in product_produced_bools))
        # Условие НЕ МЕНЬШЕ для продуктов с qty_minus=0
        if products[p].get('qty_minus', 1) == 0 and products[p]['qty'] > 0:
            model.Add(product_counts[p] >= products[p]['qty'])

    # ------------ Существующие ограничения (типы машин, кол-во простоев и т.д.) ------------
    # (Этот блок оставлен без изменений, т.к. он не затрагивается новыми требованиями)

    # Сумма PRODUCT_ZERO в смену d не более max_daily_prod_zero
    for d in all_days:
        daily_prod_zero_on_machines = [product_produced_bools[PRODUCT_ZERO, m, d] for m in all_machines if (m,d) in work_days]
        model.Add(sum(daily_prod_zero_on_machines) <= max_daily_prod_zero)

    # Ограничение по типам машин
    for p in all_products:
        product_machine_type_req = products[p]['machine_type']
        if product_machine_type_req > 0:
            for m in all_machines:
                machine_type = machines[m]['type']
                if machine_type != product_machine_type_req:
                    for d in all_days:
                        if (m, d) in work_days:
                            model.Add(jobs[m, d] != p)

    # ------------ ИЗМЕНЕНО: Логика переходов с учетом партий (`lday`) ------------

    for m in all_machines:
        # --- Начальные условия (d=0) ---
        initial_product = initial_products[m]
        remain_days = days_to_constrain[m]

        is_job_zero_d0 = model.NewBoolVar(f"is_job_zero_{m}_0")
        model.Add(jobs[m, 0] == PRODUCT_ZERO).OnlyEnforceIf(is_job_zero_d0)
        model.Add(jobs[m, 0] != PRODUCT_ZERO).OnlyEnforceIf(is_job_zero_d0.Not())

        if initial_product != PRODUCT_ZERO and remain_days > 0:
            # Машина дорабатывает остаток партии
            model.Add(jobs[m, 0] == initial_product)
            # День в партии = общая длина - остаток + 1
            model.Add(batch_day[m, 0] == ldays[initial_product] - remain_days + 1)
        elif initial_product == PRODUCT_ZERO:
            # НОВОЕ: Машина была в простое, может начать любой продукт
            model.Add(is_job_zero_d0.Not()) # Нельзя начать с простоя, если уже был простой
            model.Add(batch_day[m, 0] == 1) # Любой начатый продукт - это начало партии
        else: # initial_product != 0 and remain_days == 0
            # Партия была завершена, можно начать ту же или новую (через простой)
            # Либо продолжаем тот же продукт (начинаем новую партию)
            continue_same = model.NewBoolVar(f"continue_same_{m}_0")
            model.Add(jobs[m, 0] == initial_product).OnlyEnforceIf(continue_same)
            model.Add(batch_day[m, 0] == 1).OnlyEnforceIf(continue_same)

            # Либо начинаем переход (простой)
            model.Add(jobs[m, 0] == PRODUCT_ZERO).OnlyEnforceIf(continue_same.Not())
            model.Add(batch_day[m, 0] == 0).OnlyEnforceIf(continue_same.Not())

        # --- Общая логика для всех дней (d > 0) ---
        for d in all_days[1:]:
            if (m, d) not in work_days:
                continue
            
            # Находим предыдущий рабочий день
            prev_d = d - 1
            while (m, prev_d) not in work_days and prev_d > 0:
                prev_d -= 1
            if (m, prev_d) not in work_days:
                # Если не нашли предыдущего рабочего дня, логика как для d=0
                # (для упрощения этот случай опускаем, предполагая, что первый день всегда рабочий)
                continue

            # Вспомогательные переменные для текущего и предыдущего дня
            job_d = jobs[m, d]
            job_prev = jobs[m, prev_d]
            bday_d = batch_day[m, d]
            bday_prev = batch_day[m, prev_d]

            # Переменные для состояний
            is_job_zero = model.NewBoolVar(f"is_job_zero_{m}_{d}")
            model.Add(job_d == PRODUCT_ZERO).OnlyEnforceIf(is_job_zero)
            model.Add(job_d != PRODUCT_ZERO).OnlyEnforceIf(is_job_zero.Not())

            is_prev_job_zero = model.NewBoolVar(f"is_prev_job_zero_{m}_{d}")
            model.Add(job_prev == PRODUCT_ZERO).OnlyEnforceIf(is_prev_job_zero)
            model.Add(job_prev != PRODUCT_ZERO).OnlyEnforceIf(is_prev_job_zero.Not())
            
            is_same_prod = model.NewBoolVar(f"is_same_prod_{m}_{d}")
            model.Add(job_d == job_prev).OnlyEnforceIf(is_same_prod)
            model.Add(job_d != job_prev).OnlyEnforceIf(is_same_prod.Not())

            # 1. Если текущий день - простой (PRODUCT_ZERO)
            model.Add(bday_d == 0).OnlyEnforceIf(is_job_zero)

            # 2. Если предыдущий день был простой, а текущий - нет (начало нового продукта)
            # То текущий день - это начало новой партии.
            model.Add(bday_d == 1).OnlyEnforceIf([is_prev_job_zero, is_job_zero.Not()])

            # 3. Если и предыдущий и текущий дни - не простой
            # 3.1. Если продукт тот же -> продолжаем партию
            model.Add(bday_d == bday_prev + 1).OnlyEnforceIf([is_same_prod, is_job_zero.Not(), is_prev_job_zero.Not()])
            # 3.2. Если продукт новый -> это запрещено (должен быть переход через PRODUCT_ZERO)
            model.Add(is_same_prod == 1).OnlyEnforceIf([is_job_zero.Not(), is_prev_job_zero.Not()])

            # НОВОЕ: Ограничение на начало перехода (уход в PRODUCT_ZERO)
            # Уйти в простой можно только если партия завершена.
            lday_of_prev_job = model.NewIntVar(1, max_lday, f"lday_of_prev_job_{m}_{d}")
            # model.AddElement(индекс, массив, целевая_переменная)
            # lday_of_prev_job = ldays[job_prev]
            model.AddElement(job_prev, ldays, lday_of_prev_job)
            
            # Условие: bday_prev == lday_of_prev_job
            is_batch_finished = model.NewBoolVar(f"is_batch_finished_{m}_{d}")
            model.Add(bday_prev == lday_of_prev_job).OnlyEnforceIf(is_batch_finished)
            model.Add(bday_prev != lday_of_prev_job).OnlyEnforceIf(is_batch_finished.Not())

            # Если предыдущий день не был простоем, а текущий - простой (начало перехода),
            # то партия должна была быть завершена.
            model.AddImplication(is_job_zero, is_batch_finished).OnlyEnforceIf(is_prev_job_zero.Not())

        # Доработка начального условия доработки остатка (constrain days)
        # Это более строгий способ зафиксировать начальные дни
        for d in range(remain_days):
            if (m, d) in work_days:
                model.Add(jobs[m, d] == initial_product)
                model.Add(batch_day[m, d] == ldays[initial_product] - remain_days + 1 + d)

    # ------------ НОВОЕ: Расчет остатка партии на конец периода ------------
    for m in all_machines:
        last_day = num_days - 1
        while (m, last_day) not in work_days and last_day > 0:
            last_day -= 1
        
        if (m, last_day) in work_days:
            last_job = jobs[m, last_day]
            last_bday = batch_day[m, last_day]

            lday_of_last_job = model.NewIntVar(1, max_lday, f"lday_of_last_job_{m}")
            model.AddElement(last_job, ldays, lday_of_last_job)
            
            is_last_job_zero = model.NewBoolVar(f"is_last_job_zero_{m}")
            model.Add(last_job == PRODUCT_ZERO).OnlyEnforceIf(is_last_job_zero)
            model.Add(last_job != PRODUCT_ZERO).OnlyEnforceIf(is_last_job_zero.Not())
            
            # final_remain_day = lday_of_last_job - last_bday
            # Используем AddEquality, так как работаем с переменными
            model.Add(final_remain_day[m] == lday_of_last_job - last_bday).OnlyEnforceIf(is_last_job_zero.Not())
            model.Add(final_remain_day[m] == 0).OnlyEnforceIf(is_last_job_zero)
        else:
            model.Add(final_remain_day[m] == 0)


    # (Остальные ограничения, такие как не более одного простоя и т.д., оставлены без изменений)
    # Запрет на переход в последние 2 дня
    for m in all_machines:
        for d in range(num_days - 2, num_days):
            if (m, d) in work_days:
                model.Add(jobs[m, d] != PRODUCT_ZERO) # Упрощенное ограничение, можно уточнить

    # Не более 1-го простоя (2 дня) на машину
    for m in all_machines:
        prod_zero_on_machine = [product_produced_bools[PRODUCT_ZERO, m, d] for d in all_days if (m, d) in work_days]
        model.Add(sum(prod_zero_on_machine) <= 2)

    # ------------ Целевая функция (оставлена без изменений) ------------
    total_products_count = model.NewIntVar(0, num_machines * num_days, "total_products_count")
    model.Add(total_products_count == sum(product_counts[p] for p in range(1, len(products))))

    total_input_quantity = sum(proportions_input)
    if total_input_quantity == 0: total_input_quantity = 1 # Избегаем деления на ноль

    proportion_objective_terms = []
    
    for p in range(1, len(products)):
        if proportions_input[p] > 0:
            # product_counts[p] * total_input_quantity
            term1_expr = model.NewIntVar(0, num_machines * num_days * total_input_quantity, f"term1_{p}")
            model.AddMultiplicationEquality(term1_expr, [product_counts[p], total_input_quantity])

            # total_products_count * proportions_input[p]
            term2_expr = model.NewIntVar(0, cp_model.INT32_MAX, f"term2_{p}")
            model.AddMultiplicationEquality(term2_expr, [total_products_count, proportions_input[p]])

            # diff = term1_expr - term2_expr
            diff_var = model.NewIntVar(-cp_model.INT32_MAX, cp_model.INT32_MAX, f"diff_{p}")
            model.Add(diff_var == term1_expr - term2_expr)
            abs_diff_var = model.NewIntVar(0, cp_model.INT32_MAX, f"abs_diff_{p}")
            model.AddAbsEquality(abs_diff_var, diff_var)
            proportion_objective_terms.append(abs_diff_var)

    downtime_penalty = round(0.1 * total_input_quantity / len(work_days)) if len(work_days) > 0 else 1
    if downtime_penalty < 1:
        downtime_penalty = 1

    model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)

    # Возвращаем модель и переменные, которые нужны для вывода результата
    return model, jobs, product_counts, final_remain_day, batch_day