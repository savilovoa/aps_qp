# WARP.md

This file provides guidance to WARP (warp.dev) when working with code in this repository.

Project overview
- Python/FastAPI server планирования расписания производства

Главная библиотека для расчета расписания - ortools
pydantic - используется для API

Реализован один расчет @router.post("/plan") для ткацкого производства (функция create_model)

Описание модели:
существующая модель для планирования продукта по слудующим критериям:
- вначале на машине дорабатывается тот продукт, который указан в начальном состоянии, на количество дней указанное в remain_day
- далее либо продолжается тот-же продукт, либо указывается переход на другой продукт длительностью 2 дня и далее планируется уже другой продукт
- для указания чистки существует специальный продукт с индексом 0 PRODUCT_ZERO
- есть ограничения на переходы - в один день не более 3-х переходов - max_daily_prod_zero
- ограничение на типы машин, для продукта с machine_type > 0 разрешены машины только type=machine_type, если machine_type = 0 то можно на любой машине
- не более одного перехода 
- если есть чистка в на машине в определенный день, то машина пропускает день производства
- мягкое ограничение - минимизировать отклонение от заданных пропорций qty
- использование длины партии lday:
	1.1 каждый продукт вырабатывается партиями длиной lday 
	1.2 переход можно использовать только после окончания партии
	1.3 reamin_day - это количество остатка партии на начало периода
- если индекс продукта на машине product_idx=0,то на ней можно начинать любой продукт
- если указано qty_minus = 0, то можно планировать количество меньше чем во входных данных, если =1, то количество плана не меньше, чем во входных данных


функция оптимального результата - минимум отклонений от пропорций и минимум переходов: model.Minimize(sum(proportion_objective_terms) + product_counts[PRODUCT_ZERO] * downtime_penalty)


Environment configuration (loaded via pydantic-settings from .env)
# LOOM
LOOM_MAX_TIME=600 - максимальное время расчета
CALC_TEST_DATA=false - укзаывает на признак тестового запуска
SOLVER_ENUMERATE=false - режим расчета                                     
APPLY_QTY_MINUS=false - переопределение логики расчета - отключение использования 
APPLY_INDEX_UP=false - логика выбора другого артикула для планирования: если true, то индекс следующего продукта на машине должен быть больше текущего (для исключения прижков: продукт 1, затем продукт 2, затем опять продукт 1)

Run the server
- With .env configured: run.cmd

Run for testing (planning data from a file)
- In `.env` set `CALC_TEST_DATA=true`.
- Optionally set `TEST_INPUT_FILE` to choose the input JSON (defaults to `example/test_in.json`):
  - `TEST_INPUT_FILE=example/simple_test_data.json` — минимальный тест (3 станка × 21 день), должен давать статус `OPTIMAL`.
  - `TEST_INPUT_FILE=example/middle_test_in.json` — промежуточный тест (12 станков × 42 дня), должен давать статус как минимум `FEASIBLE`.
  - `TEST_INPUT_FILE=example/test_in.json` — полный расчёт (48 станков × 84 дня), может давать `UNKNOWN` при текущих ограничениях.
- Запуск: `run.cmd` (вызывает `python run.py`). В режиме `CALC_TEST_DATA=true` поднимается не сервер, а выполняется `calc_test_data_from` в `src/main.py`.

Result verification workflow
- Перед тестовым запуском удалить старый лог, чтобы видеть только свежий результат:
  - PowerShell: `if (Test-Path .\\log\\aps-loom.log) { Remove-Item .\\log\\aps-loom.log }`
- Запустить `run.cmd`.
- После завершения посмотреть лог `log/aps-loom.log`:
  - Найти строки вида `Создание модели: num_machines=..., num_days=..., work_days=..., max_daily_prod_zero=...` и `lday[...]` — убедиться, что все `lday` для продуктов с `idx>0` > 0.
  - Найти строку `Сводка по продуктам: минимально требуемое количество и машинные дни ёмкости` и убедиться, что значения `min_required` и `capacity_machine_days` выглядят корректно.
  - Найти строку `total_input_quantity=...` и блок `proportions_input[...]`.
  - Контрольный статус решателя: строка `Статус решения: ...`:
    - Ожидаемые значения:
      - для `simple_test_data.json`: `OPTIMAL`;
      - для `middle_test_in.json`: как минимум `FEASIBLE`;
      - для полного `test_in.json`: возможен `UNKNOWN` при жёстких ограничениях.
- В случае ошибки в данных (например, `lday<=0` у реального продукта) расчёт не выполняется, а в лог пишется сообщение вида:
  - `Некорректные данные: продукт(ы) имеют lday<=0: idx=..., name='...', lday=...`
  - В этом случае нужно исправить входной JSON и повторить запуск.
